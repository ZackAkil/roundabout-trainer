<!DOCTYPE html>
<html>
  <head>
    <title>Roundabout Training</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #f0f0f0;
      }
    </style>
  </head>
  <body>
    <script>
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        backgroundColor: "#FFFFFF", // Add this line to set white background
        physics: {
          default: "arcade",
          arcade: {
            debug: false,
          },
        },
        scene: {
          preload: preload,
          create: create,
          update: update,
        },
      };

      const game = new Phaser.Game(config);
      let car;

      function preload() {
        this.load.image("car", "assets/car.png");
        this.load.image("point", "assets/point.png");
        this.load.image("indicator", "assets/indicator.png");
        this.load.image("roundabout", "assets/roundabout.png");
      }

      function create() {
        const roundabout = new RoundaboutImage(
          this,
          400,
          300,
          "roundabout",
          0.5
        );

        car = new Car(this, 400, 550, "car", (scale = 0.07));

        const route = new Route(
          this,
          [
            [400, 300],
            [400, 100],
            [100, 300],
            [700, 300],
          ],
          car
        );

        const resetButton = this.add
          .text(700, 16, "Reset", {
            fontSize: "32px",
            fill: "#000",
          })
          .setInteractive();

        resetButton.on("pointerdown", () => {
          car.reset();
          route.reset();
        });
      }

      function update() {
        if (!car) return;
        car.update();
      }

      class Car {
        maxSpeed = 2;
        acceleration = 0.05;
        deceleration = 0.01;
        brakingPower = 0.1;
        turningSpeed = 0.1;
        turningDamper = 0.05;
        maxTurningAngle = 3;
        minTurningAngle = -3;

        constructor(scene, x, y, texture, scale) {
          this.scene = scene;

          this.cursors = scene.input.keyboard.createCursorKeys();

          scene.input.keyboard.on(
            "keydown-Z",
            this.toggleLeftIndicator.bind(this)
          );
          scene.input.keyboard.on(
            "keydown-X",
            this.toggleRightIndicator.bind(this)
          );

          this.startPosition = { x, y };

          this.container = scene.add.container(x, y);

          this.sprite = scene.add.sprite(0, 0, texture).setScale(scale);
          this.scene.physics.world.enable(this.sprite);
          this.container.add(this.sprite);

          this.sprite.angle = 0;
          this.speed = 0;
          this.currentTurningAngle = 0;

          this.rightIndicatorOn = false;
          this.leftIndicatorOn = false;

          this.indicatorTimer = setInterval(
            this.blinkIndicators.bind(this),
            500
          );

          this.leftIndicators = scene.add.container(0, 0).setVisible(false);
          this.rightIndicators = scene.add.container(0, 0).setVisible(false);

          this.frontLeftIndicator = scene.add
            .sprite(-15, -30, "indicator")
            .setScale(0.1);

          this.backLeftIndicator = scene.add
            .sprite(-15, 30, "indicator")
            .setScale(0.1);

          this.leftIndicators.add(this.frontLeftIndicator);
          this.leftIndicators.add(this.backLeftIndicator);

          this.frontRightIndicator = scene.add
            .sprite(15, -30, "indicator")
            .setScale(0.1);

          this.backRightIndicator = scene.add
            .sprite(15, 30, "indicator")
            .setScale(0.1);

          this.rightIndicators.add(this.frontRightIndicator);
          this.rightIndicators.add(this.backRightIndicator);

          this.container.add(this.leftIndicators);
          this.container.add(this.rightIndicators);

          this.scene.physics.world.enable(this.container);
          this.container.body.setSize(this.sprite.width, this.sprite.height);
        }

        blinkIndicators() {
          if (this.rightIndicatorOn)
            this.rightIndicators.setVisible(!this.rightIndicators.visible);
          else this.rightIndicators.setVisible(false);

          if (this.leftIndicatorOn)
            this.leftIndicators.setVisible(!this.leftIndicators.visible);
          else this.leftIndicators.setVisible(false);
        }

        reset() {
          this.container.x = this.startPosition.x;
          this.container.y = this.startPosition.y;
          this.container.angle = 0;
          this.speed = 0;
          this.currentTurningAngle = 0;
        }

        update() {
          // Handle acceleration
          if (this.cursors.up.isDown) {
            this.speed = Math.min(
              this.maxSpeed,
              this.speed + this.acceleration
            );
          } else {
            this.speed = Math.max(0, this.speed - this.deceleration);
          }
          // Handle braking
          if (this.cursors.down.isDown) {
            this.speed = Math.max(0, this.speed - this.brakingPower);
          }

          // Apply movement with current speed
          if (this.speed > 0) {
            const rad = Phaser.Math.DegToRad(this.container.angle - 90);
            this.container.x += Math.cos(rad) * this.speed;
            this.container.y += Math.sin(rad) * this.speed;
          }

          // Handle turning
          if (this.cursors.left.isDown) {
            this.currentTurningAngle = Math.max(
              this.minTurningAngle,
              this.currentTurningAngle - this.turningSpeed
            );
          } else if (this.cursors.right.isDown) {
            this.currentTurningAngle = Math.min(
              this.maxTurningAngle,
              this.currentTurningAngle + this.turningSpeed
            );
          } else {
            if (this.currentTurningAngle > 0) {
              this.currentTurningAngle = Math.max(
                0,
                this.currentTurningAngle - this.turningDamper
              );
            } else if (this.currentTurningAngle < 0) {
              this.currentTurningAngle = Math.min(
                0,
                this.currentTurningAngle + this.turningDamper
              );
            }
          }
          this.container.angle +=
            this.currentTurningAngle * (this.speed / this.maxSpeed);
        }

        setRightIndicator(visible) {
          this.rightIndicatorOn = visible;
        }
        setLeftIndicator(visible) {
          this.leftIndicatorOn = visible;
        }
        toggleRightIndicator() {
          console.log("toggleRightIndicator ");
          if (this.leftIndicatorOn) {
            this.leftIndicatorOn = false;
          }
          this.rightIndicatorOn = !this.rightIndicatorOn;
        }
        toggleLeftIndicator() {
          console.log("toggleLeftIndicator ");
          if (this.rightIndicatorOn) {
            this.rightIndicatorOn = false;
          }
          this.leftIndicatorOn = !this.leftIndicatorOn;
        }
      }

      class RoundaboutImage {
        constructor(scene, x, y, texture, scale) {
          this.scene = scene;
          this.x = x;
          this.y = y;
          this.sprite = scene.add.sprite(x, y, texture).setScale(scale);
        }
      }

      class Waypoint {
        constructor(scene, x, y, car) {
          this.scene = scene;
          this.circle = scene.add.circle(x, y, 10, 0x0000ff);
          this.scene.physics.add.existing(this.circle);
          this.circle.body.setImmovable(true);

          scene.physics.add.overlap(car.sprite, this.circle, () => {
            this.onCollide();
          });
        }

        onCollide() {
          console.log("Collided!");
          this.circle.visible = false;
        }

        reset() {
          this.circle.visible = true;
        }
      }

      class Route {
        constructor(scene, waypointCoordinates, car) {
          this.scene = scene;
          this.car = car;
          this.waypointCoordinates = waypointCoordinates;
          this.waypoints = [];
          this.createWaypoints();
        }

        createWaypoints() {
          for (let i = 0; i < this.waypointCoordinates.length; i++) {
            this.waypoints.push(
              new Waypoint(
                this.scene,
                this.waypointCoordinates[i][0],
                this.waypointCoordinates[i][1],
                this.car
              )
            );
          }
        }

        reset() {
          for (let i = 0; i < this.waypoints.length; i++) {
            this.waypoints[i].reset();
          }
        }
      }
    </script>
  </body>
</html>
