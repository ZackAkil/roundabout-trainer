<!DOCTYPE html>
<html>
  <head>
    <title>Roundabout Training</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #f0f0f0;
      }
    </style>
  </head>
  <body>
    <script>
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        backgroundColor: "#FFFFFF", // Add this line to set white background
        physics: {
          default: "arcade",
          arcade: {
            debug: false,
          },
        },
        scene: {
          preload: preload,
          create: create,
          update: update,
        },
      };

      const game = new Phaser.Game(config);
      let car;
      let cursors;
      let score = 0;
      let scoreText;

      function preload() {
        this.load.image("car", "assets/car.png");
        this.load.image("point", "assets/point.png");
        this.load.image("indicator", "assets/indicator.png");
        this.load.image("roundabout", "assets/roundabout.png");
      }

      function create() {
        // Create roundabout object
        // const roundabout = new Roundabout(
        //   this,
        //   (x = 400),
        //   (y = 300),
        //   (innerRadius = 100),
        //   (innerRadius = 150)
        // );

        const roundabout = new RoundaboutImage(
          this,
          400,
          300,
          "roundabout",
          0.5
        );

        car = new Car(this, 400, 550, "car", (scale = 0.07));

        scoreText = this.add.text(16, 16, "Score: 0", {
          fontSize: "32px",
          fill: "#000",
        });

        cursors = this.input.keyboard.createCursorKeys();

        this.input.keyboard.on("keydown-I", () => {
          car.toggleLeftIndicator();
        });
        this.input.keyboard.on("keydown-O", () => {
          car.toggleRightIndicator();
        });

        // // Create points around the roundabout
        // this.points = this.physics.add.group({
        //   key: "point",
        //   repeat: 7,
        //   setXY: { x: 400, y: 300, stepX: 100, stepY: 0 },
        // });

        // this.points.children.iterate(function (child) {
        //   child.setCircle(2); // Set the size of the points
        // });

        // // Add collision detection between car and points
        // this.physics.add.overlap(car.sprite, this.points, hitPoint, null, this);
      }

      function hitPoint(car, point) {
        point.destroy();
        score += 10;
        scoreText.setText("Score: " + score);
      }

      function update() {
        if (!car) return;
        car.update(cursors);
      }

      class Car {
        maxSpeed = 5;
        acceleration = 0.1;
        deceleration = 0.01;
        brakingPower = 0.1;
        turningSpeed = 0.5;
        turningDamper = 0.1;
        maxTurningAngle = 4;
        minTurningAngle = -4;

        constructor(scene, x, y, texture, scale) {
          this.scene = scene;

          this.container = scene.add.container(x, y);

          this.sprite = scene.add.sprite(0, 0, texture).setScale(scale);
          this.scene.physics.world.enable(this.sprite);
          this.container.add(this.sprite);

          this.sprite.angle = 0;
          this.speed = 0;
          this.currentTurningAngle = 0;

          this.rightIndicatorOn = false;
          this.leftIndicatorOn = false;

          this.indicatorTimer = setInterval(
            this.blinkIndicators.bind(this),
            500
          );

          this.leftIndicators = scene.add.container(0, 0).setVisible(false);
          this.rightIndicators = scene.add.container(0, 0).setVisible(false);

          this.frontLeftIndicator = scene.add
            .sprite(-15, -30, "indicator")
            .setScale(0.1);

          this.backLeftIndicator = scene.add
            .sprite(-15, 30, "indicator")
            .setScale(0.1);

          this.leftIndicators.add(this.frontLeftIndicator);
          this.leftIndicators.add(this.backLeftIndicator);

          this.frontRightIndicator = scene.add
            .sprite(15, -30, "indicator")
            .setScale(0.1);

          this.backRightIndicator = scene.add
            .sprite(15, 30, "indicator")
            .setScale(0.1);

          this.rightIndicators.add(this.frontRightIndicator);
          this.rightIndicators.add(this.backRightIndicator);

          this.container.add(this.leftIndicators);
          this.container.add(this.rightIndicators);

          this.scene.physics.world.enable(this.container);
          this.container.body.setSize(this.sprite.width, this.sprite.height);
        }

        blinkIndicators() {
          if (this.rightIndicatorOn)
            this.rightIndicators.setVisible(!this.rightIndicators.visible);
          else this.rightIndicators.setVisible(false);

          if (this.leftIndicatorOn)
            this.leftIndicators.setVisible(!this.leftIndicators.visible);
          else this.leftIndicators.setVisible(false);
        }

        update(cursors) {
          // Handle acceleration
          if (cursors.up.isDown) {
            this.speed = Math.min(
              this.maxSpeed,
              this.speed + this.acceleration
            );
          } else {
            this.speed = Math.max(0, this.speed - this.deceleration);
          }
          // Handle braking
          if (cursors.down.isDown) {
            this.speed = Math.max(0, this.speed - this.brakingPower);
          }

          // Apply movement with current speed
          if (this.speed > 0) {
            const rad = Phaser.Math.DegToRad(this.container.angle - 90);
            this.container.x += Math.cos(rad) * this.speed;
            this.container.y += Math.sin(rad) * this.speed;
          }

          // Handle turning
          if (cursors.left.isDown) {
            this.currentTurningAngle = Math.max(
              this.minTurningAngle,
              this.currentTurningAngle - this.turningSpeed
            );
          } else if (cursors.right.isDown) {
            this.currentTurningAngle = Math.min(
              this.maxTurningAngle,
              this.currentTurningAngle + this.turningSpeed
            );
          } else {
            if (this.currentTurningAngle > 0) {
              this.currentTurningAngle = Math.max(
                0,
                this.currentTurningAngle - this.turningDamper
              );
            } else if (this.currentTurningAngle < 0) {
              this.currentTurningAngle = Math.min(
                0,
                this.currentTurningAngle + this.turningDamper
              );
            }
          }
          this.container.angle +=
            this.currentTurningAngle * (this.speed / this.maxSpeed);
        }

        setRightIndicator(visible) {
          this.rightIndicatorOn = visible;
        }
        setLeftIndicator(visible) {
          this.leftIndicatorOn = visible;
        }
        toggleRightIndicator() {
          console.log("toggleRightIndicator ");
          if (this.leftIndicatorOn) {
            this.leftIndicatorOn = false;
          }
          this.rightIndicatorOn = !this.rightIndicatorOn;
        }
        toggleLeftIndicator() {
          console.log("toggleLeftIndicator ");
          if (this.rightIndicatorOn) {
            this.rightIndicatorOn = false;
          }
          this.leftIndicatorOn = !this.leftIndicatorOn;
        }
      }

      class RoundaboutImage {
        constructor(scene, x, y, texture, scale) {
          this.scene = scene;
          this.x = x;
          this.y = y;
          this.sprite = scene.add.sprite(x, y, texture).setScale(scale);
        }
      }

      class Roundabout {
        constructor(scene, x, y, innerRadius, outerRadius) {
          this.scene = scene;
          this.x = x;
          this.y = y;
          this.innerRadius = innerRadius;
          this.outerRadius = outerRadius;
          this.graphics = scene.add.graphics();
          this.drawRoundabout();
        }

        drawRoundabout() {
          // Draw inner circle
          this.graphics.lineStyle(4, 0x666666);
          this.graphics.strokeCircle(this.x, this.y, this.innerRadius);

          // Draw outer circle
          this.graphics.lineStyle(4, 0x666666);
          this.graphics.strokeCircle(this.x, this.y, this.outerRadius);

          // Draw exits
          this.graphics.lineStyle(4, 0x666666);
          this.graphics.moveTo(this.x, this.y - this.outerRadius);
          this.graphics.lineTo(this.x, this.y - this.outerRadius - 50);
          this.graphics.strokePath();

          this.graphics.moveTo(this.x + this.outerRadius, this.y);
          this.graphics.lineTo(this.x + this.outerRadius + 50, this.y);
          this.graphics.strokePath();

          this.graphics.moveTo(this.x, this.y + this.outerRadius);
          this.graphics.lineTo(this.x, this.y + this.outerRadius + 50);
          this.graphics.strokePath();

          this.graphics.moveTo(this.x - this.outerRadius, this.y);
          this.graphics.lineTo(this.x - this.outerRadius - 50, this.y);
          this.graphics.strokePath();
        }
      }
    </script>
  </body>
</html>
